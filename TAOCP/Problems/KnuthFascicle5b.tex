\def\newstep#1{\smallskip \noindent {\bf #1}}
\def\newprob#1{\vskip 0.12in \noindent {\bf #1}}

\topglue 0.5in
\centerline{\tt Knuth Fascicle 5b}
\vskip 0.3in

\noindent {\bf Problem~1} {\it Generating Combinatoric Quantities using 
Backtracking}\hfil\break
(a) $n$-tuples: $D_k$ is whatever the domain is and $P_l$ is always 
true.\hfil\break 
(b) Permutations: $D_k = \{ 1, \ldots, n \}$ and $P_l$ is that all the elements 
are distinct.\hfil\break
(c) Combinations: $D_k = \{1, \ldots, N + 1 - k \}$ and 
$P_l = x_1 < \ldots < x_l$.\hfil\break

\newprob {Problem~2} {\it Making $P_1$ always true}\hfil\break
Simply discard any elements of $D_1$ that do not satisfy $P_1$.

\newprob {Problem~3} {\it Saving half the work for $n$-queens}\hfil\break
Restrict $D_1$ to be only the first half of the range, and then add the 
reflected solution $n + 1 - x_1, \ldots, n + 1 - x_n$.  For example, if $n = 8$
then $D_1 = \{1, 2, 3, 4\}$.

\newprob {Problem~4} {\it Recursive backtracking}\hfil\break
{\bf I1.} [Initialize] Set $l \leftarrow 0$ and initialize other data 
structures.\hfil\break
{\bf I2.} [Test $P_l$] If $P_l\left(x_1 \ldots x_l\right)$ set 
 $l \leftarrow l + 1$ and $x_l \leftarrow {\rm min}\,D_l$,
  otherwise goto {\bf I4}.\hfil\break 
{\bf I3.} [Visit] If $l > n$ visit $x_1 \ldots x_n$, set $l \leftarrow l-1$.
\hfil\break
{\bf I4.} [Iterate] Set $x_l$ to the next larger element in $D_l$ and goto 
 {\bf I2}. If there is no such element set $l \leftarrow l - 1$.\hfil\break
{\bf I5.} [Done] If $l=0$ halt, otherwise goto {\bf I2}.
\hfil\break

So, why not use something like this?  Really, the answer is because Don Knuth
is an assembly programmer, and that's the way he thinks.  One could argue his
algorithm is faster, which could be critical in large problems, but tests show
the difference is small when coded in a higher level language -- in fact this
way is sometimes faster.

\newprob {Problem~5} {\it NQueens skipping one row.}\hfil\break
For $n=8$, skipping row $0, 1, \ldots, 7$ gives ${312, 396,
430, 458, 458, 430, 396, 312}$ solutions.

\newprob {Problem~9} {\it Bitwise N-Queens}\hfil\break
Obviously we will represent the current state of the $A_l, B_l, C_l$ 
as integers $a_l, b_l, c_l$, one for each level, and where, for example, 
$a_l\left[i\right] = 1$ if and only if $x_{i-1}$ is present in $A_l$.  
Similarly, $S_l$ will be represented by integers $s_l$.  Let 
$m = \left(1 \ll {n-1}\right)$, which is a bitmask on the available elements
for $x$.

Then in {\bf W2}, to compute the available values,
$s_l \leftarrow m \,\&\, {\bar a_{l-1}} \,\&\, {\bar b_{l-1}} \,\&\, 
{\bar c_{l-1}}$. We compute the bitwise representation of the current choice 
for $x$ to chose as $x \leftarrow s_l \& \left(- s_l\right)$, then 
$a_l \leftarrow a_{l-1} + t$, $b_l \leftarrow \left(b_{l-1} + t\right) \gg 1$, 
and  $c_l \leftarrow \left( {c_{l-1} + t} \ll 1 \right) \,\&\, m$.  The shifts 
are necessary for $b, c$ because $l$ has increased.  In {\bf W4} we
remove that choice by doing $s_l \leftarrow s_l - t$, although since we keep
all the $s_l$, we can do it in W2 if desired.

\newprob {Problem 15} {\it Hexwise N-Queens}\hfil\break
This is like N-Queens except we only need to check one diagonal.  This turns out
to be like ignoring $b$ from Problem~9.

Then we have $n=1: 1, 2: 1, 3: 3, 4: 7, 5: 23, 6: 83, 7: 405, 8: 2113, 9: 12657,
10: 82297$.

\newprob {Problem 20} {\it Forced move in Langford.}\hfil\break
We need a new array $a$ where $a_i$ means that $i$ has already appeared.
We initially set it to all 0s, and when we chose the value in {\bf L3}
we set $a_k \leftarrow 1$.  Similarly, when we undo in $L_5$ we set
$a_k \leftarrow 0$.

The more interesting changes have to do with forcing a value.  First,
we don't need to do any checks if $l < n - 1$ since nothing can be forced
before that.  We force moves in {\bf L3}, after we determine we are not
off the end (that is, after the $l + k + 1 \le 2 n$ check), we check to see 
if the forced value has already been used.  If it has, continue, if not
then we have to force it by walking the list forward until it is selected.
So: if $l \ge n - 1$ and $a_{2n - l - 1} = 0$, while $l + k + 1 \ne 2 n$
set $j \leftarrow k$, $k \leftarrow p_k$.  We are guaranteed this will
terminate because we know it is available by checking $a$.

But we can also modify $l$ by walking over used values in {\bf L2}, which
may lead us to realize we are out of room.  So, in {\bf L2} while looping
forward over negative values, we immediately backtrack (jump to {\bf L5}).
So: while $x_l < 0$, if $l \ge n - 1$ and $a_{2 n - l - 1} = 0$ goto {\bf L5},
otherwise set $l \leftarrow l + 1$.
\bye